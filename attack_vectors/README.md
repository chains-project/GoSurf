# Go Supply Chain Attack Vectors 
The Go language explicitly focuses on [addressing supply chain attacks](https://go.dev/blog/supply-chain). Despite this, in the following, we report go-specific features that may be misused by attackers to hide or execute arbitrary code in the context of downstream project. 

For each of these cases, we provided a simple proof-of-concept demonstrating how the attack vector could be exploited to execute malicious actions. 


## Execute Code at the Pre-Built Time 
During the pre-build phase, third-party dependency integration encompasses various operations. Attackers can exploit these operations to hide and execute malicious code. 


### [I1] Static Code Generation [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/prebuild_time/generators)
Execution of code contained in installation code invoked/generated by using `go:generate` directive. `go generate` scans Go files for `go:generate` directives, identifying generator functions, responsible for automatic code generation. 

`main.go` file:
```go
package main

//go:generate go run generate.go

func main() {
    generatedFunc()
}
```

`generate.go` file:
```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // malicious code here
    
    legit_code_to_generate := `
package main

import (
    "os/exec"
    "fmt"
)

func generatedFunc() {
    // Generated legit code
}
`
    // Write the malicious code to a file
    _ := os.WriteFile("generated.go", []byte(legit_code_to_generate), 0644)
}
```
Run the code generation tool, which will both generate the `generated.go` and insidiously execute the malicious code. 
```bash 
go generate
```

**N.B.**: `go generate` is not part of `go build` and requires explicit invocation beforehand. It lacks dependency analysis and operates solely on the shipping module, primarily intended for use by package authors rather than clients.


### [I2] Testing Functions [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/build_time/generators)
Execution of code contained in the testing functions and execute with `go test` tool.  

`main.go` file:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

`main_test.go` file:
```go
package main

import (
    "os"
    "testing"
)

func TestMalicious(t *testing.T) {
    // malicious code here 
}
```
Run automatically the test and insidiously execute the malicious code. 
```bash 
go test
```



## Execute Code at Initialization-Time
The Go Runtime supports initialization operations executed before the main logic by means of global variable initialization and init() functions. Although these mechanisms are useful for initializing packages, arbitrary code can be injected and executed through them.


### [I1] Global Variable Initialization [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/init_time/global_init)
Anonymous or regular functions used to initialize complex global variable are immediately executed upon the import. 

```go
package mylib

var global_var string = func() string {
    // malicious code here
    return ""
}()
```


### [I2] Initialization Hooks [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/init_time/init_func)
Any init functions declared within the package scope of the imported packages or the main package are executed. These functions are called in the order they are declared within their respective packages.

```go
package mylib

func init() {
    // malicious code here
}
```

**N.B.** Importing a package with an underscore prefix prevents Go from automatically removing unused dependencies. This ensures that even if the package is not directly used in the code, its init() function or any anonymous functions assigned to global variables will still be executed.


## Execute Code at the Run-Time 
Go has various constructs that can be leveraged to hide and run malicious code during main execution time. 


### [E1] Construtors methods [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/constructors)
Attackers may target constructor methods as suitable places to insert malicious code because those functions are frequently used in the code to create instances of a struct. While Go doesn't have traditional constructors, developers often define and use common functions as "constructor" functions to initialize structs.


```go                                                 
package mylib
import "fmt"

// Define a struct type
type Person struct {
    Name string
    Age  int
}

// Constructor-like function for Person
func NewPerson(name string, age int) *Person {
    // malicious code here
    return &Person{
        Name: name,
        Age:  age,
    }
}

```


### [E2] Reflection [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/reflection)
Reflection in Go enables dynamic inspection and manipulation of structures, functions, and variables at runtime, facilitating flexible and generic code. Attackers can insert malicious code by exploiting the reflection feature, making challenging to analyze the behavior and the intent of functions and code statically.


```golang
package main

import (
	"fmt"
	"reflect"
)

type Foo struct{}

func (f Foo) Method() {
	// malicious code here
}

func main() {
	var f Foo
	v := reflect.ValueOf(f)
	m := v.MethodByName("Method")
	m.Call(nil) 
}
```


### [E3] Interface Polymorphism [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/interfaces)
Attackers can use Go's interface mechanism for dynamic method dispatch. When methods are indirectly invoked via an interface, their specific implementation is determined at runtime, posing challenges for static detection of malicious behavior. 

```golang
package main

type DynamicMethodInterface interface {
    Invoke()
}

type MethodA struct{}
func (m MethodA) Invoke() {
    // Malicious code here
}

type MethodB struct{}
func (m MethodB) Invoke() {
    // Malicious code here
}

func main() {

    methodA := MethodA{}
    methodB := MethodB{}

    invokeMethod(methodA)
    invokeMethod(methodB)
}

func invokeMethod(method DynamicMethodInterface)
```

### [E4] Unsafe pointers [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/unsafe)

TODO


### [E5] CGO feature [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/cgo)
CGO features enable executing C code in Go binaries. Attackers could exploit this capability to gain more control over the system, and also exploit memory safety concerns related to these low level languages.  

```golang
package main

/*
#include <stdio.h>

void cFunction() {
    // malicious code here
}
*/
import "C"

type Invoker struct{}

func (i Invoker) InvokeMethod() {
    C.cFunction()
}

func main() {
    invoker := Invoker{}
    invoker.InvokeMethod()
}
```


### [E6] Assembly linked objects [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/assembly)
Attackers can introduce malicious code into some functions defined in assembly files.

Create an assembly file `asm.s` with a function definition:
```asm
// +build amd64

#include "textflag.h"

// func AsmFunction() int
TEXT Â·AsmFunction(SB), NOSPLIT, $0-8
    MOVQ $42, AX
    MOVQ AX, ret+0(FP)
    // Malcious code here
    RET
```

Create a Go file `main.go` that declare and use a function with the same name as the defined assembly function: 
```go
package main

import (
	"fmt"
)

func AsmFunction() int

func main() {
	result := AsmFunction()
	fmt.Println("Result from assembly function:", result)
}
```
Build in module-aware mode executing `go mod init` and `go build` to compile and link the objects together.


### [E7] E7. Dynamic Library Linking  [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/plugins)
Attackers can load pre-build externa binary as plugins using the Go plugin system.  

```go
// plugin.go
package main

func PluginFunc() {
	// malicious code here
}
```

```bash
go build -buildmode=plugin -o plugin.so plugin.go
```

```go
package main

import "fmt"
import "plugin"

func main() {
	// Load the plugin dynamically
	p, _ := plugin.Open("./plugin.so")
	
    	// Look up the symbol (function) from the loaded plugin
	sym, _ := p.Lookup("PluginFunc")
	
    	// Assert and call the function if found
	if fn, ok := sym.(func()); ok {
		fn()
	} else {
		fmt.Println("PluginFunc has unexpected type")
	}
}
```

### [E8] Dynamic External Execution [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/exec)
Attackers can execute pre-built code or arbitrary external commands using the os package. 

```go
package main

import (
    "fmt"
    "os/exec"
)

func main() {
    binaryPath := "/path/to/prebuilt/binary"
    cmd := exec.Command(binaryPath)
    _ := cmd.Run()
}
```
