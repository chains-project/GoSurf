# Arbitrary Code Execution Strategies
The Go language explicitly focuses on [addressing supply chain attacks](https://go.dev/blog/supply-chain). Despite this, in the following, we report techniques that 3rd-party Go dependencies may employ to attain ACE when they are installed or run in the context of downstream project. 

For each of these cases, we provided a simple proof-of-concept demonstrating how the attack vector could be exploited executing malicious actions. 

In addition, we used the Capslock tool to analyze the capabilities invoked through the identified ACE strategies, and provided some insights into the obtained outcomes (specifically, whether Capslock could properly identify the capabilities or not).


## Execute Code at the Build-Time 
Some techniques can be used to achieve ACE when downstream projects install a 3rd-party dependency using package managers, or installation scripts. 

### [B1] Installation code [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/build_time/generators)
Execution of code contained in installation code invoked/generated by using `go:generate` directive. `go generate` scans Go files for `go:generate` directives, identifying generator functions, responsible for automatic code generation. 

`main.go` file:
```go
package main

//go:generate go run generate.go

func main() {
    generatedFunc()
}
```

`generate.go` file:
```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // malicious code here
    
    legit_code_to_generate := `
package main

import (
    "os/exec"
    "fmt"
)

func generatedFunc() {
    // Generated legit code
}
`
    // Write the malicious code to a file
    _ := os.WriteFile("generated.go", []byte(legit_code_to_generate), 0644)
}
```
Run the code generation tool, which will both generate the `generated.go` and insidiously execute the malicious code. 
```bash 
go generate
```

**N.B.**: `go generate` is not part of `go build` and requires explicit invocation beforehand. It lacks dependency analysis and operates solely on the shipping module, primarily intended for use by package authors rather than clients.

## Execute Code at Initialization-Time
There are two techniques to achieve ACE at initialization time, upon package import and before executing the actual main of the importing package, with higher order of precedence.  

### [I1] Variable initialization [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/init_time/anonym_func)
Anonymous functions used to initialize complex global variable are immediately executed upon the import. 

```go
package mylib

var anonym_func string = func() string {
    // malicious code here
    return ""
}()
```

- **Capslock Outcome**: <span style="color:green">*NO FALSE NEGATIVE*</span>

- **Details**: Identifies the real capability within the method.

### [I2] Package initialization [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/init_time/init_func)
 Any init functions declared within the package scope of the imported packages or the main package are executed. These functions are called in the order they are declared within their respective packages.

```go
package mylib

func init() {
    // malicious code here
}
```

**N.B.** Importing a package with an underscore prefix prevents Go from automatically removing unused dependencies. This ensures that even if the package is not directly used in the code, its init() function or any anonymous functions assigned to global variables will still be executed.


- **Capslock Outcome**: <span style="color:green">*NO FALSE NEGATIVE*</span>

- **Details**: Identifies the real capability within the method.


## Execute Code at the Run-Time 
Some techniques can be used to achieve ACE at runtime when the project and its dependencies run. 

### [R1] Construtors methods [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/run_time/constructors)
Attackers may target constructor methods as suitable places to insert malicious code because those functions are frequently used in the code to create instances of a struct. While Go doesn't have traditional constructors, developers often define and use common functions as "constructor" functions to initialize structs.


```go                                                 
package mylib
import "fmt"

// Define a struct type
type Person struct {
    Name string
    Age  int
}

// Constructor-like function for Person
func NewPerson(name string, age int) *Person {
    // malicious code here
    return &Person{
        Name: name,
        Age:  age,
    }
}

```

- **Capslock Outcome**: <span style="color:green">*NO FALSE NEGATIVE*</span>

- **Details**: Identifies the real capability within the method.


### [R2] Reflection [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/run_time/reflection)
Reflection in Go enables dynamic inspection and manipulation of structures, functions, and variables at runtime, facilitating flexible and generic code. Attackers can insert malicious code by exploiting the reflection feature, making challenging to analyze the behavior and the intent of functions and code statically.


```golang
package main

import (
	"fmt"
	"reflect"
)

type Foo struct{}

func (f Foo) Method() {
	// malicious code here
}

func main() {
	var f Foo
	v := reflect.ValueOf(f)
	m := v.MethodByName("Method")
	m.Call(nil) 
}
```

- **Capslock Outcome**: <span style="color:orange">*WEAK FALSE NEGATIVE*</span>

- **Details**: Detects only the `CAPABILITY_REFLECT`, but cannot detect the real capability

- **TODO**: Try other real-world examples, because it might identify the real capability.


### [R3] Indirect method invocations via interfaces [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/run_time/interfaces)
Attackers can use Go's interface mechanism for dynamic method dispatch. When methods are indirectly invoked via an interface, their specific implementation is determined at runtime, posing challenges for static detection of malicious behavior. 

```golang
package main

type DynamicMethodInterface interface {
    Invoke()
}

type MethodA struct{}
func (m MethodA) Invoke() {
    // Malicious code here
}

type MethodB struct{}
func (m MethodB) Invoke() {
    // Malicious code here
}

func main() {

    methodA := MethodA{}
    methodB := MethodB{}

    invokeMethod(methodA)
    invokeMethod(methodB)
}

func invokeMethod(method DynamicMethodInterface)
```

- **Capslock Outcome**: <span style="color:green">*NO FALSE NEGATIVE*</span>

- **Details**: Identifies the real capability within the method.

- **TODO**: Investigate the false positives.


### [R4] CGO feature [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/run_time/cgo)
CGO features enable executing C code in Go binaries. Attackers could exploit this capability to gain more control over the system, and also exploit memory safety concerns related to these low level languages.  

```golang
package main

/*
#include <stdio.h>

void cFunction() {
    // malicious code here
}
*/
import "C"

type Invoker struct{}

func (i Invoker) InvokeMethod() {
    C.cFunction()
}

func main() {
    invoker := Invoker{}
    invoker.InvokeMethod()
}
```
- **Capslock Outcome**: <span style="color:orange">*WEAK FALSE NEGATIVE*</span>

- **Details**: Detects only the `CAPABILITY_CGO`, but cannot detect the actual capability.

- **TODO**: Investigate the false positives.

### [R5] Unsafe pointers [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/run_time/unsafe)


### [R6] os/exec package [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/run_time/exec)
Attackers can execute pre-built code or arbitrary external commands using the os package. 

```go
package main

import (
    "fmt"
    "os/exec"
)

func main() {
    binaryPath := "/path/to/prebuilt/binary"
    cmd := exec.Command(binaryPath)
    _ := cmd.Run()
}
```

- **Outcomes**: <span style="color:orange">*WEAK FALSE NEGATIVE*</span>

- **Details**: Detects only the `CAPABILITY_EXEC`, but cannot detect the actual capabilities.


### [R7] Plugin system  [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/run_time/plugins)
Attackers can load pre-build externa binary as plugins using the Go plugin system.  

```go
// plugin.go
package main

func PluginFunc() {
	// malicious code here
}
```

```bash
go build -buildmode=plugin -o plugin.so plugin.go
```

```go
package main

import "fmt"
import "plugin"

func main() {
	// Load the plugin dynamically
	p, _ := plugin.Open("./plugin.so")
	
    	// Look up the symbol (function) from the loaded plugin
	sym, _ := p.Lookup("PluginFunc")
	
    	// Assert and call the function if found
	if fn, ok := sym.(func()); ok {
		fn()
	} else {
		fmt.Println("PluginFunc has unexpected type")
	}
}
```

- **Outcomes**: <span style="color:orange">*WEAK FALSE NEGATIVE*</span>

- **Details**: Detects only the `CAPABILITY_EXEC`, but cannot detect the actual capabilities. We can specialize the identified capability into `CAPABILITY_PLUGIN`

### [R8] Dynamically generated code [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/run_time/dyngen_code)
Attackers can insert functions to dynamically generate and execute code at runtime, creating temporary files, building and executing them. This could make detecting malicious behaviors challenging. 

```golang
package main

import (
    "fmt"
    "os"
    "os/exec"
)

type Foo struct{}

func (f Foo) Method() {}

func GenerateCode() string {
        return `package main

                type Foo struct{}

                func (f Foo) Method() {
                        // malicious code here
                }

                func main() {
                        f := Foo{}
                        f.Method()
                }
                `
}

func main() {
    code := GenerateCode()

    // Create a temporary Go file to hold the generated code
    file, _ := os.CreateTemp("", "generated_*.go")
    defer os.Remove(file.Name()) // Clean up temporary file

    // Write the generated code to the temporary file
    file.WriteString(code);
    file.Close();

    // Run the Go file
    cmd := exec.Command("go", "run", file.Name())
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    cmd.Run()
}

```

- **Capslock Outocome**: <span style="color:orange">*WEAK FALSE NEGATIVE*</span>

- **Details**: Detects only the `CAPABILITY_EXEC`, but cannot detect the actual capabilities.