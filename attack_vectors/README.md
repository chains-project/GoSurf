# Arbitrary Code Execution Strategies
The Go language explicitly focuses on [addressing supply chain attacks](https://go.dev/blog/supply-chain). Despite this, in the following, we report techniques that 3rd-party Go dependencies may employ to attain ACE when they are installed or run in the context of downstream project. 

For each of these cases, we provided a simple proof-of-concept demonstrating how the attack vector could be exploited executing malicious actions. 

## Execute Code at the Install-Time 
Some techniques can be used to achieve ACE when downstream projects install a 3rd-party dependency using package managers, or installation scripts. 

### [I1] Static Code Generation [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/build_time/generators)
Execution of code contained in installation code invoked/generated by using `go:generate` directive. `go generate` scans Go files for `go:generate` directives, identifying generator functions, responsible for automatic code generation. 

`main.go` file:
```go
package main

//go:generate go run generate.go

func main() {
    generatedFunc()
}
```

`generate.go` file:
```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // malicious code here
    
    legit_code_to_generate := `
package main

import (
    "os/exec"
    "fmt"
)

func generatedFunc() {
    // Generated legit code
}
`
    // Write the malicious code to a file
    _ := os.WriteFile("generated.go", []byte(legit_code_to_generate), 0644)
}
```
Run the code generation tool, which will both generate the `generated.go` and insidiously execute the malicious code. 
```bash 
go generate
```

**N.B.**: `go generate` is not part of `go build` and requires explicit invocation beforehand. It lacks dependency analysis and operates solely on the shipping module, primarily intended for use by package authors rather than clients.


### [I2] Testing Functions [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/build_time/generators)
Execution of code contained in the testing functions and execute with `go test` tool.  

`main.go` file:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

`main_test.go` file:
```go
package main

import (
    "os"
    "testing"
)

func TestMalicious(t *testing.T) {
    // malicious code here 
}
```
Run automatically the test and insidiously execute the malicious code. 
```bash 
go test
```





## Execute Code at Initialization-Time
There are two techniques to achieve ACE at initialization time, upon package import and before executing the actual main of the importing package, with higher order of precedence.  

### [I1] Anonymous Functions [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/init_time/anonym_func)
Anonymous functions used to initialize complex global variable are immediately executed upon the import. 

```go
package mylib

var anonym_func string = func() string {
    // malicious code here
    return ""
}()
```


### [I2] Initialization Hooks [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/init_time/init_func)
 Any init functions declared within the package scope of the imported packages or the main package are executed. These functions are called in the order they are declared within their respective packages.

```go
package mylib

func init() {
    // malicious code here
}
```

**N.B.** Importing a package with an underscore prefix prevents Go from automatically removing unused dependencies. This ensures that even if the package is not directly used in the code, its init() function or any anonymous functions assigned to global variables will still be executed.


## Execute Code at the Run-Time 
Some techniques can be used to achieve ACE at runtime when the project and its dependencies run. 

### [R1] Construtors methods [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/constructors)
Attackers may target constructor methods as suitable places to insert malicious code because those functions are frequently used in the code to create instances of a struct. While Go doesn't have traditional constructors, developers often define and use common functions as "constructor" functions to initialize structs.


```go                                                 
package mylib
import "fmt"

// Define a struct type
type Person struct {
    Name string
    Age  int
}

// Constructor-like function for Person
func NewPerson(name string, age int) *Person {
    // malicious code here
    return &Person{
        Name: name,
        Age:  age,
    }
}

```


### [R2] Reflection [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/reflection)
Reflection in Go enables dynamic inspection and manipulation of structures, functions, and variables at runtime, facilitating flexible and generic code. Attackers can insert malicious code by exploiting the reflection feature, making challenging to analyze the behavior and the intent of functions and code statically.


```golang
package main

import (
	"fmt"
	"reflect"
)

type Foo struct{}

func (f Foo) Method() {
	// malicious code here
}

func main() {
	var f Foo
	v := reflect.ValueOf(f)
	m := v.MethodByName("Method")
	m.Call(nil) 
}
```


### [R3] Indirect method invocations via interfaces [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/interfaces)
Attackers can use Go's interface mechanism for dynamic method dispatch. When methods are indirectly invoked via an interface, their specific implementation is determined at runtime, posing challenges for static detection of malicious behavior. 

```golang
package main

type DynamicMethodInterface interface {
    Invoke()
}

type MethodA struct{}
func (m MethodA) Invoke() {
    // Malicious code here
}

type MethodB struct{}
func (m MethodB) Invoke() {
    // Malicious code here
}

func main() {

    methodA := MethodA{}
    methodB := MethodB{}

    invokeMethod(methodA)
    invokeMethod(methodB)
}

func invokeMethod(method DynamicMethodInterface)
```

### [R4] CGO feature [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/cgo)
CGO features enable executing C code in Go binaries. Attackers could exploit this capability to gain more control over the system, and also exploit memory safety concerns related to these low level languages.  

```golang
package main

/*
#include <stdio.h>

void cFunction() {
    // malicious code here
}
*/
import "C"

type Invoker struct{}

func (i Invoker) InvokeMethod() {
    C.cFunction()
}

func main() {
    invoker := Invoker{}
    invoker.InvokeMethod()
}
```


### [R5] Assembly linked objects [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/assembly)
Attackers can introduce malicious code into some functions defined in assembly files.

Create an assembly file `asm.s` with a function definition:
```asm
// +build amd64

#include "textflag.h"

// func AsmFunction() int
TEXT Â·AsmFunction(SB), NOSPLIT, $0-8
    MOVQ $42, AX
    MOVQ AX, ret+0(FP)
    // Malcious code here
    RET
```

Create a Go file `main.go` that declare and use a function with the same name as the defined assembly function: 
```go
package main

import (
	"fmt"
)

func AsmFunction() int

func main() {
	result := AsmFunction()
	fmt.Println("Result from assembly function:", result)
}
```
Build in module-aware mode executing `go mod init` and `go build` to compile and link the objects together.


### [R6] os/exec package [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/exec)
Attackers can execute pre-built code or arbitrary external commands using the os package. 

```go
package main

import (
    "fmt"
    "os/exec"
)

func main() {
    binaryPath := "/path/to/prebuilt/binary"
    cmd := exec.Command(binaryPath)
    _ := cmd.Run()
}
```


### [R7] Plugin system  [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/plugins)
Attackers can load pre-build externa binary as plugins using the Go plugin system.  

```go
// plugin.go
package main

func PluginFunc() {
	// malicious code here
}
```

```bash
go build -buildmode=plugin -o plugin.so plugin.go
```

```go
package main

import "fmt"
import "plugin"

func main() {
	// Load the plugin dynamically
	p, _ := plugin.Open("./plugin.so")
	
    	// Look up the symbol (function) from the loaded plugin
	sym, _ := p.Lookup("PluginFunc")
	
    	// Assert and call the function if found
	if fn, ok := sym.(func()); ok {
		fn()
	} else {
		fmt.Println("PluginFunc has unexpected type")
	}
}
```


### [R8] Unsafe pointers [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/unsafe)

TODO

### [R9] Dynamically generated code [[POC]](https://github.com/chains-project/capslock-analysis/tree/main/attack_vectors/runtime/dyngen_code)
Attackers can insert functions to dynamically generate and execute code at runtime, creating temporary files, building and executing them. This could make detecting malicious behaviors challenging. 

```golang
package main

import (
    "fmt"
    "os"
    "os/exec"
)

type Foo struct{}

func (f Foo) Method() {}

func GenerateCode() string {
        return `package main

                type Foo struct{}

                func (f Foo) Method() {
                        // malicious code here
                }

                func main() {
                        f := Foo{}
                        f.Method()
                }
                `
}

func main() {
    code := GenerateCode()

    // Create a temporary Go file to hold the generated code
    file, _ := os.CreateTemp("", "generated_*.go")
    defer os.Remove(file.Name()) // Clean up temporary file

    // Write the generated code to the temporary file
    file.WriteString(code);
    file.Close();

    // Run the Go file
    cmd := exec.Command("go", "run", file.Name())
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    cmd.Run()
}

```
